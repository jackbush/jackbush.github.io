{"version":3,"file":"component---src-pages-index-js-8c1fc742012a3fda7526.js","mappings":"gNAIO,MCMDA,EAAyB,CAC7BC,SAAU,QACVC,IAAK,EACLC,KAAM,EACNC,MAAO,OACPC,OAAQ,OACRC,QAAS,GAcX,MAXkB,IAEd,gBAAC,IAAM,KACL,uBAAKC,MAAOP,EAAwBQ,GAjBhB,iBAkBpB,4BACE,sBAAID,MAAOE,EAAAA,GAAAA,OAAkB,U","sources":["webpack://jackbush-homepage/./src/sketches/blob.js","webpack://jackbush-homepage/./src/pages/index.js"],"sourcesContent":["import p5 from \"p5\";\nimport { coreColour, semanticColour } from \"../tokens\";\nimport { measureContainer, jitter } from \"./_utils\";\n\nexport const blobSketchLoader = (containerId) => {\n\tconst sketch = function (p) {\n\t\tlet container;\n\t\tlet canvas;\n\t\tlet brandDevice;\n\t\tconst config = {\n\t\t\tframeRate: 60,\n\t\t\tlayers: 5,\n\t\t\t// float: 0 = transparent, 1 = opaque\n\t\t\topacity: 0.15,\n\t\t\t// Decimal value between 0 and 1\n\t\t\t// NOTE other stuff breaks when this isn't 0.1\n\t\t\tspread: 0.1,\n\t\t\t// Arbitrary constants...\n\t\t\tspeed: 20,\n\t\t\tacceleration: 100,\n\n\t\t\tblobColour: coreColour.lightblue,\n\t\t\tbackgroundColour: semanticColour.background,\n\t\t};\n\n\t\t// Convert opacity to the scale p5 expects...\n\t\tconfig.opacity *= 255;\n\t\t// Convert speed to be independent of framerate (defaults to 60)\n\t\tconfig.speed /= config.frameRate;\n\t\t// Correct speed for how we actually use it -- otherwise things get really counterintuitive\n\t\tconfig.speed *= -1;\n\n\t\tp.setup = function () {\n\t\t\t// Set framerate\n\t\t\tp.frameRate(config.frameRate);\n\n\t\t\t// Get container details\n\t\t\tcontainer = measureContainer(containerId);\n\n\t\t\t// Create a canvas from container size\n\t\t\tcanvas = p.createCanvas(container.width, container.height);\n\n\t\t\t// Attach canvas to container\n\t\t\tcanvas.parent(containerId);\n\n\t\t\t// Get position for brand device, create and add blobs\n\t\t\tconst position = p.createVector(\n\t\t\t\tcontainer.width * 0.5,\n\t\t\t\tcontainer.height * 0.5\n\t\t\t);\n\t\t\tbrandDevice = new Cluster(position);\n\t\t\tbrandDevice.add(config.layers);\n\n\t\t\t// If it's not been done, change generic colour to the p5 format with opapcity\n\t\t\tif (config.blobColour === coreColour.lightblue) {\n\t\t\t\tconfig.blobColour = p.color(\n\t\t\t\t\tconfig.blobColour.r,\n\t\t\t\t\tconfig.blobColour.g,\n\t\t\t\t\tconfig.blobColour.b,\n\t\t\t\t\tconfig.opacity\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Set p5's fill and stroke here, as they don't change\n\t\t\tp.fill(config.blobColour);\n\t\t\tp.noStroke();\n\t\t};\n\n\t\t// Set to re-start on window resize\n\t\tp.windowResized = p.setup;\n\n\t\tp.draw = function () {\n\t\t\tp.background(config.backgroundColour);\n\t\t\tbrandDevice.update();\n\t\t\tbrandDevice.display();\n\t\t};\n\n\t\t// A Cluster is a collection of Blobs, which share a center.\n\t\tfunction Cluster(position) {\n\t\t\tthis.blobs = [];\n\t\t\tthis.center = p.createVector(position.x, position.y);\n\t\t}\n\n\t\tCluster.prototype.add = function (numberOfLayers) {\n\t\t\tnumberOfLayers = numberOfLayers || 1;\n\t\t\tfor (let i = 0; i < numberOfLayers; i++) {\n\t\t\t\tthis.blobs.push(new Blob(this.center));\n\t\t\t}\n\t\t};\n\n\t\tCluster.prototype.update = function () {\n\t\t\tthis.blobs.forEach(function (blob) {\n\t\t\t\tblob.update();\n\t\t\t});\n\t\t};\n\n\t\tCluster.prototype.display = function () {\n\t\t\tthis.blobs.forEach(function (blob) {\n\t\t\t\tblob.display();\n\t\t\t});\n\t\t};\n\n\t\t// A Blob is an irregular, undulating shape\n\t\tfunction Blob(position) {\n\t\t\tthis.position = p.createVector(position.x, position.y);\n\n\t\t\t// Hard-coded because the coordinate system only works for five!\n\t\t\tthis.points = [\n\t\t\t\tnew Point(0),\n\t\t\t\tnew Point(1),\n\t\t\t\tnew Point(2),\n\t\t\t\tnew Point(3),\n\t\t\t\tnew Point(4),\n\t\t\t];\n\n\t\t\t// This is the order we must draw points to create the blob:\n\t\t\t// [0, 3, 1, 4, 2]\n\n\t\t\t// This loops around three points further at each end, for a smooth join\n\t\t\tthis.drawCycle = [1, 4, 2, 0, 3, 1, 4, 2, 0, 3, 1];\n\t\t}\n\n\t\tBlob.prototype.update = function () {\n\t\t\tthis.points.forEach(function (point) {\n\t\t\t\tpoint.update();\n\t\t\t});\n\t\t};\n\n\t\tBlob.prototype.display = function () {\n\t\t\tp.beginShape();\n\n\t\t\tconst that = this;\n\t\t\tthis.drawCycle.forEach(function (n) {\n\t\t\t\tp.curveVertex(\n\t\t\t\t\tthat.position.x + that.points[n].position.x,\n\t\t\t\t\tthat.position.y + that.points[n].position.y\n\t\t\t\t);\n\t\t\t});\n\n\t\t\tp.endShape(p.CLOSE);\n\t\t};\n\n\t\tfunction Point(vertex) {\n\t\t\t// Vertex is an index, going clockwise from 12 o'clock\n\t\t\t// This is used by the getCoordinates function\n\t\t\tthis.vertex = vertex;\n\n\t\t\tthis.radius = jitter(container.height * 0.35, 0.25);\n\t\t\tthis.initialRadius = this.radius;\n\t\t\tthis.minRadius = this.radius * (1 - config.spread);\n\t\t\tthis.maxRadius = this.radius * (1 + config.spread);\n\n\t\t\t// Which direction the point starts moving in\n\t\t\tthis.isGrowing = Math.random() < 0.5;\n\n\t\t\t// Points are created with a position for flexibility\n\t\t\tthis.position = this.getCoordinates(this.vertex, this.radius);\n\t\t}\n\n\t\tPoint.prototype.update = function () {\n\t\t\t// Change directions if radius is out of bounds\n\t\t\t// The adjustment of min and max here is because otherwise we get stuck in limits!\n\t\t\tif (this.radius >= this.maxRadius * 0.99) this.isGrowing = false;\n\t\t\tif (this.radius <= this.minRadius * 1.01) this.isGrowing = true;\n\n\t\t\t// position is the point's position between min (-spread) and max (spread);\n\t\t\tconst position = this.radius / this.initialRadius - 1;\n\t\t\t// delta is the difference between the current radius and the next one\n\t\t\tlet delta =\n\t\t\t\tconfig.acceleration * config.speed * Math.pow(position, 2) -\n\t\t\t\tconfig.speed;\n\n\t\t\t// Correct radius change for direction\n\t\t\tif (!this.isGrowing) delta *= -1;\n\n\t\t\t// Update radius and position\n\t\t\tthis.radius += delta;\n\t\t\tthis.position = this.getCoordinates(this.vertex, this.radius);\n\t\t};\n\n\t\tPoint.prototype.getCoordinates = function (vertex, radius) {\n\t\t\tconst result = {\n\t\t\t\tx: 0.0,\n\t\t\t\ty: 0.0,\n\t\t\t};\n\n\t\t\t// This is sepecifically for a five-point blob\n\t\t\t// This only has three options because symmetry\n\t\t\tswitch (vertex) {\n\t\t\t\tcase 0:\n\t\t\t\t\tresult.x = 0;\n\t\t\t\t\tresult.y = -1 * radius;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\tcase 4:\n\t\t\t\t\tresult.x = radius * p.cos(18);\n\t\t\t\t\tresult.y = -1 * radius * p.sin(18);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\tcase 3:\n\t\t\t\t\tresult.x = radius * p.cos(54);\n\t\t\t\t\tresult.y = radius * p.sin(54);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Mirrors for left-side points\n\t\t\tif (vertex === 3 || vertex === 4) result.x *= -1;\n\n\t\t\treturn result;\n\t\t};\n\t};\n\n\treturn new p5(sketch, containerId);\n};\n","import * as React from \"react\";\nimport Layout from \"../components/layout\";\nimport { typography } from \"../tokens\";\nimport { blobSketchLoader } from \"../sketches/blob\";\n\nconst sketchContainerId = \"jsSketchBlob\";\n// TODO: this only works on intial load\n// SHONK: the listener is never removed\n// document.addEventListener(\"ready\", blobSketchLoader(sketchContainerId));\n\nconst sketchContainterStyles = {\n  position: \"fixed\",\n  top: 0,\n  left: 0,\n  width: \"100%\",\n  height: \"100%\",\n  zIndex: -1,\n};\n\nconst IndexPage = () => {\n  return (\n    <Layout>\n      <div style={sketchContainterStyles} id={sketchContainerId} />\n      <main>\n        <h1 style={typography.title}>ðŸ‘‹ Hi</h1>\n      </main>\n    </Layout>\n  );\n};\n\nexport default IndexPage;\n\n// export const Head = () => <title>Home Page</title>\n"],"names":["sketchContainterStyles","position","top","left","width","height","zIndex","style","id","typography"],"sourceRoot":""}