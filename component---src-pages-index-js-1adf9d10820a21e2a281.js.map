{"version":3,"file":"component---src-pages-index-js-1adf9d10820a21e2a281.js","mappings":"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","sources":["webpack://jackbush-homepage/./src/sketches/_utils.js","webpack://jackbush-homepage/./src/sketches/blob.js","webpack://jackbush-homepage/./src/pages/index.js"],"sourcesContent":["export const measureContainer = (containerId) => {\n  const size = {};\n\n  const el = document.getElementById(containerId);\n  if (el) {\n    size.width = el.clientWidth;\n    size.height = el.clientHeight;\n    return size;\n  }\n};\n\n// This is used to give numbers a variance, defaulting to 10%\nexport const jitter = (number, factor) => {\n  factor = factor || 0.1;\n  const range = number * factor * Math.random() * 2;\n  const variance = range - range / 2;\n  return number + variance;\n};\n\n// Takes a hex code and channel ('r', 'g' or 'b') and returns 8bit int\nexport const getRgbFromHex = (hex, channel) => {\n  let startIdx;\n  if (channel === \"r\") {\n    startIdx = 1;\n  } else if (channel === \"g\") {\n    startIdx = 3;\n  } else if (channel === \"b\") {\n    startIdx = 5;\n  } else {\n    throw new Error(\"Channel must be r, g or b\");\n  }\n\n  const channelHex = hex.slice(startIdx, startIdx + 2);\n  return parseInt(channelHex, 16);\n};\n","import { coreColour, semanticColour } from \"../tokens\";\nimport { measureContainer, jitter, getRgbFromHex } from \"./_utils\";\n\n// SHONK: p5 uses window, this stops that from breaking SSR\nconst p5 = typeof window !== `undefined` ? require(\"p5\") : null;\n\nexport const blobSketchLoader = (containerId) => {\n  const sketch = function (p) {\n    let container;\n    let canvas;\n    let blob;\n    const config = {\n      frameRate: 60,\n      layers: 5,\n      // Decimal value between 0 and 1\n      // NOTE other stuff breaks when this isn't 0.1\n      spread: 0.1,\n      // Arbitrary constants...\n      speed: 20,\n      acceleration: 100,\n\n      // colours\n      blobHex: coreColour.lightBlue,\n      // float: 0 = transparent, 255 = opaque\n      opacity: 40,\n      backgroundColour: semanticColour.background,\n    };\n\n    // Convert speed to be independent of framerate (defaults to 60)\n    config.speed /= config.frameRate;\n    // Correct speed for how we actually use it -- otherwise things get really counterintuitive\n    config.speed *= -1;\n    // make a colour object from hex + opacity\n    config.blobColour = p.color(\n      getRgbFromHex(config.blobHex, \"r\"),\n      getRgbFromHex(config.blobHex, \"g\"),\n      getRgbFromHex(config.blobHex, \"b\"),\n      config.opacity,\n    );\n\n    p.setup = function () {\n      // Set framerate\n      p.frameRate(config.frameRate);\n\n      // Get container details\n      container = measureContainer(containerId);\n\n      // Create a canvas from container size\n      canvas = p.createCanvas(container.width, container.height);\n\n      // Attach canvas to container\n      canvas.parent(containerId);\n\n      // Get position for brand device, create and add blobs\n      const position = p.createVector(\n        container.width * 0.5,\n        container.height * 0.5,\n      );\n      blob = new Cluster(position);\n      blob.add(config.layers);\n\n      // Set p5's fill and stroke here, as they don't change\n      p.fill(config.blobColour);\n      p.noStroke();\n    };\n\n    // Set to re-start on window resize\n    p.windowResized = p.setup;\n\n    p.draw = function () {\n      p.background(config.backgroundColour);\n      blob.update();\n      blob.display();\n    };\n\n    // A Cluster is a collection of Blobs, which share a center.\n    function Cluster(position) {\n      this.blobs = [];\n      this.center = p.createVector(position.x, position.y);\n    }\n\n    Cluster.prototype.add = function (numberOfLayers) {\n      numberOfLayers = numberOfLayers || 1;\n      for (let i = 0; i < numberOfLayers; i++) {\n        this.blobs.push(new Blob(this.center));\n      }\n    };\n\n    Cluster.prototype.update = function () {\n      this.blobs.forEach(function (blob) {\n        blob.update();\n      });\n    };\n\n    Cluster.prototype.display = function () {\n      this.blobs.forEach(function (blob) {\n        blob.display();\n      });\n    };\n\n    // A Blob is an irregular, undulating shape\n    function Blob(position) {\n      this.position = p.createVector(position.x, position.y);\n\n      // Hard-coded because the coordinate system only works for five!\n      this.points = [\n        new Point(0),\n        new Point(1),\n        new Point(2),\n        new Point(3),\n        new Point(4),\n      ];\n\n      // This is the order we must draw points to create the blob:\n      // [0, 3, 1, 4, 2]\n\n      // This loops around three points further at each end, for a smooth join\n      this.drawCycle = [1, 4, 2, 0, 3, 1, 4, 2, 0, 3, 1];\n    }\n\n    Blob.prototype.update = function () {\n      this.points.forEach(function (point) {\n        point.update();\n      });\n    };\n\n    Blob.prototype.display = function () {\n      p.beginShape();\n\n      const that = this;\n      this.drawCycle.forEach(function (n) {\n        p.curveVertex(\n          that.position.x + that.points[n].position.x,\n          that.position.y + that.points[n].position.y,\n        );\n      });\n\n      p.endShape(p.CLOSE);\n    };\n\n    function Point(vertex) {\n      // Vertex is an index, going clockwise from 12 o'clock\n      // This is used by the getCoordinates function\n      this.vertex = vertex;\n\n      this.radius = jitter(container.height * 0.35, 0.25);\n      this.initialRadius = this.radius;\n      this.minRadius = this.radius * (1 - config.spread);\n      this.maxRadius = this.radius * (1 + config.spread);\n\n      // Which direction the point starts moving in\n      this.isGrowing = Math.random() < 0.5;\n\n      // Points are created with a position for flexibility\n      this.position = this.getCoordinates(this.vertex, this.radius);\n    }\n\n    Point.prototype.update = function () {\n      // Change directions if radius is out of bounds\n      // The adjustment of min and max here is because otherwise we get stuck in limits!\n      if (this.radius >= this.maxRadius * 0.99) this.isGrowing = false;\n      if (this.radius <= this.minRadius * 1.01) this.isGrowing = true;\n\n      // position is the point's position between min (-spread) and max (spread);\n      const position = this.radius / this.initialRadius - 1;\n      // delta is the difference between the current radius and the next one\n      let delta =\n        config.acceleration * config.speed * Math.pow(position, 2) -\n        config.speed;\n\n      // Correct radius change for direction\n      if (!this.isGrowing) delta *= -1;\n\n      // Update radius and position\n      this.radius += delta;\n      this.position = this.getCoordinates(this.vertex, this.radius);\n    };\n\n    Point.prototype.getCoordinates = function (vertex, radius) {\n      const result = {\n        x: 0.0,\n        y: 0.0,\n      };\n\n      // This is sepecifically for a five-point blob\n      // This only has three options because symmetry\n      switch (vertex) {\n        case 0:\n          result.x = 0;\n          result.y = -1 * radius;\n          break;\n        case 1:\n        case 4:\n          result.x = radius * p.cos(18);\n          result.y = -1 * radius * p.sin(18);\n          break;\n        case 2:\n        case 3:\n          result.x = radius * p.cos(54);\n          result.y = radius * p.sin(54);\n          break;\n        default:\n          break;\n      }\n\n      // Mirrors for left-side points\n      if (vertex === 3 || vertex === 4) result.x *= -1;\n\n      return result;\n    };\n  };\n\n  return new p5(sketch, containerId);\n};\n","import * as React from \"react\";\nimport Layout from \"../components/layout\";\nimport { blobSketchLoader } from \"../sketches/blob\";\n\nconst sketchContainerId = \"jsSketchBlob\";\n\nconst sketchContainterStyles = {\n  position: \"fixed\",\n  top: 0,\n  left: 0,\n  width: \"100%\",\n  height: \"100%\",\n  zIndex: -1,\n};\n\nconst IndexPage = () => {\n  React.useEffect(() => {\n    blobSketchLoader(sketchContainerId);\n  }, []);\n  return (\n    <Layout>\n      <div style={sketchContainterStyles} id={sketchContainerId} />\n    </Layout>\n  );\n};\n\nexport default IndexPage;\n"],"names":["getRgbFromHex","hex","channel","startIdx","Error","channelHex","slice","parseInt","p5","window","require","blobSketchLoader","containerId","p","container","canvas","blob","config","frameRate","layers","spread","speed","acceleration","blobHex","coreColour","lightBlue","opacity","backgroundColour","semanticColour","background","Cluster","position","this","blobs","center","createVector","x","y","Blob","points","Point","drawCycle","vertex","radius","jitter","number","factor","range","Math","random","height","initialRadius","minRadius","maxRadius","isGrowing","getCoordinates","blobColour","color","setup","size","el","document","getElementById","width","clientWidth","clientHeight","measureContainer","createCanvas","parent","add","fill","noStroke","windowResized","draw","update","display","prototype","numberOfLayers","i","push","forEach","point","beginShape","that","n","curveVertex","endShape","CLOSE","delta","pow","result","cos","sin","sketchContainerId","sketchContainterStyles","top","left","zIndex","IndexPage","React","Layout","style","id"],"sourceRoot":""}